<!DOCTYPE html>
<html>

  <head>
    <meta name="description" content="Spinning cube example">
    <meta charset="utf-8">
    <title>Computação Gráfica</title>
    <link rel="shortcut icon" href="data:image/png;base64,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">
    <script id="vs" type="not-js">
      attribute vec3 vPosition;
      attribute vec3 vColor;
      varying vec3 fColor;
      uniform mat4 uMVP;

      void main(void) {
        gl_Position = uMVP * vec4(vPosition, 2.0);
	    fColor = vColor;
      }
    </script>

    <script id="fs" type="not-js">
      precision highp float;
      varying vec3 fColor;

      void main(void) {
	     gl_FragColor = vec4(fColor, 1);
      }
    </script>

  </head>

  <body onload="start()">
    <canvas id="mycanvas" width="1280" height="766"></canvas><br>
    <input id="slider1" type="range" min="-100" max="100" />
    <input id="slider2" type="range" min="-100" max="100" />
    <script src="twgl-full.min.js"></script>
    <script src="desenhos.js"></script>
		<script>

      // draw a textured cube using WebGL
//
// written by sifakis on October 18, 2015

function start() { "use strict";

// Get canvas, WebGL context, twgl.m4
var canvas = document.getElementById("mycanvas");
var gl = canvas.getContext("webgl");
var m4 = twgl.m4;

// Sliders at center
var slider1 = document.getElementById('slider1');
slider1.value = 0;
var slider2 = document.getElementById('slider2');
slider2.value = 0;

// Read shader source
var vertexSource = document.getElementById("vs").text;
var fragmentSource = document.getElementById("fs").text;

// Compile vertex shader
var vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,vertexSource);
gl.compileShader(vertexShader);
if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
  alert(gl.getShaderInfoLog(vertexShader)); return null; }

// Compile fragment shader
var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,fragmentSource);
gl.compileShader(fragmentShader);
if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
  alert(gl.getShaderInfoLog(fragmentShader)); return null; }

// Attach the shaders and link
var shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertexShader);
gl.attachShader(shaderProgram, fragmentShader);
gl.linkProgram(shaderProgram);
if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
  alert("Could not initialize shaders"); }
gl.useProgram(shaderProgram);	    

// with the vertex shader, we need to pass it positions
// as an attribute - so set up that communication
shaderProgram.PositionAttribute = gl.getAttribLocation(shaderProgram, "vPosition");
gl.enableVertexAttribArray(shaderProgram.PositionAttribute);

shaderProgram.ColorAttribute = gl.getAttribLocation(shaderProgram, "vColor");
gl.enableVertexAttribArray(shaderProgram.ColorAttribute);    

// this gives us access to the matrix uniform
shaderProgram.MVPmatrix = gl.getUniformLocation(shaderProgram,"uMVP");

// Data ...

// vertex positions

var vertexPos_first = vertices_diamante;

var vertexPos_second = vertices_diamante_2;
// vertex colors

var vertexColors_first = vertexColors_diamante;

var vertexColors_second = vertexColors_diamante;

// element index array

var triangleIndices_first = indices_diamante;

var triangleIndices_second = indices_diamante;
var c;

console.log("casa:");
console.log(vertices_casa);
console.log(vertexColors_casa);
console.log(indices_casa);
console.log("diamont");
console.log(vertices_diamante);
console.log(vertexColors_diamante);
console.log(indices_diamante);

// we need to put the vertices into a buffer so we can
// block transfer them to the graphics hardware
var trianglePosBuffer_first = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, trianglePosBuffer_first);
gl.bufferData(gl.ARRAY_BUFFER, vertexPos_first, gl.STATIC_DRAW);
trianglePosBuffer_first.itemSize = 3;
trianglePosBuffer_first.numItems = triangleIndices_first.length;

var trianglePosBuffer_second = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, trianglePosBuffer_second);


gl.bufferData(gl.ARRAY_BUFFER, vertexPos_second,gl.STATIC_DRAW);
trianglePosBuffer_second.itemSize = 3;
trianglePosBuffer_second.numItems = triangleIndices_second.length;

// a buffer for colors
var colorBuffer_first = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer_first);
gl.bufferData(gl.ARRAY_BUFFER, vertexColors_first, gl.STATIC_DRAW);
colorBuffer_first.itemSize = 4;
colorBuffer_first.numItems = vertexColors_first.length;

var colorBuffer_second = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer_second);
gl.bufferData(gl.ARRAY_BUFFER, vertexColors_second, gl.STATIC_DRAW);
colorBuffer_second.itemSize = 4;
colorBuffer_second.numItems = vertexColors_second.length;

// a buffer for indices
var indexBuffer_first = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer_first);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triangleIndices_first, gl.STATIC_DRAW);    

var indexBuffer_second = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer_second);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triangleIndices_second, gl.STATIC_DRAW);    

              // Scene (re-)draw routine
function draw() {

    // Translate slider values to angles in the [-pi,pi] interval
    var angle1 = slider1.value*0.01*Math.PI;
    var angle2 = slider2.value*0.01*Math.PI;

    // Circle around the y-axis
    var eye = [400*Math.sin(angle1),150.0,500.0*Math.cos(angle1)];
    var target = [0,0,0];
    var up = [0,1,0];

    var tModel1 = m4.multiply(m4.scaling([100,100,100]),m4.axisRotation([1,1,1],angle2));
    var tModel2 = m4.scaling([100,100,100]);
    var tCamera = m4.inverse(m4.lookAt(eye,target,up));
    var tProjection = m4.perspective(Math.PI/3,1,10,1000);

    var tMVP1=m4.multiply(m4.multiply(tModel1,tCamera),tProjection);
    var tMVP2=m4.multiply(m4.multiply(tModel2,tCamera),tProjection);

    // Clear screen, prepare for rendering
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Set up uniforms & attributes
    gl.uniformMatrix4fv(shaderProgram.MVPmatrix,false,tMVP1);
             
    gl.bindBuffer(gl.ARRAY_BUFFER, trianglePosBuffer_first);
    gl.vertexAttribPointer(shaderProgram.PositionAttribute, trianglePosBuffer_first.itemSize,
      gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer_first);
    gl.vertexAttribPointer(shaderProgram.ColorAttribute, colorBuffer_first.itemSize,
      gl.FLOAT,false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer_first);

    // Do the drawing
    gl.drawElements(gl.TRIANGLES, triangleIndices_first.length, gl.UNSIGNED_BYTE, 0);

    // Set up uniforms & attributes
    gl.uniformMatrix4fv(shaderProgram.MVPmatrix,false,tMVP2);
             
    gl.bindBuffer(gl.ARRAY_BUFFER, trianglePosBuffer_second);
    gl.vertexAttribPointer(shaderProgram.PositionAttribute, trianglePosBuffer_second.itemSize,
      gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer_second);
    gl.vertexAttribPointer(shaderProgram.ColorAttribute, colorBuffer_second.itemSize,
      gl.FLOAT,false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer_second);

    // Do the drawing
    gl.drawElements(gl.TRIANGLES, triangleIndices_second.length, gl.UNSIGNED_BYTE, 0);
}

slider1.addEventListener("input",draw);
slider2.addEventListener("input",draw);
draw();
}


    </script>
  </body>

</html>
