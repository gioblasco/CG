<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Jogo do Labirinto</title>
    <style>
        body {
            color: #ffffff;
            font-family: Arial;
            font-size: 15px;
            text-align: center;
            font-weight: bold;

            background-color: purple;
            margin: 0px;
            overflow: hidden;
            cursor: none;
        }
    </style>
</head>

<body>

    <h1 id="header" style="color:lightblue">Labirinto do Pooh</h1>
    <h3> Ajude o ursinho achar o
        <span id="piglet" style="color:orange">Leitão</span>, o
        <span id="tigger" style="color:orange">Tigrão</span>, sua
        <span id="ball" style="color:orange">bola colorida</span> e o principal, seu
        <span id="honey" style="color:orange">pote de mel</span>! </h3>

    <div id="inicio" style="margin-top: 20em; color:lightblue">
        <h3>
            <span style="border: 1px solid white; border-radius: 10px; padding: 2em;">Para iniciar o jogo, pressione a tecla
                Espaço
            </span>
        </h3>
    </div>

    <div id="fim" style="margin-top: 20em; margin-bottom: 40em; color:lightblue">
        <h1> Parabéns! Você ajudou o Pooh a achar tudo o que ele queria e agora ele está muito feliz! </h1>
    </div>

    <script src="../three/three.js"></script>
    <script src="../three/OBJLoader.js"></script>
    <script src="../three/MTLLoader.js"></script>
    <script src="../three/inflate.min.js"></script>
    <script src="../three/FBXLoader.js"></script>
    <script src="walls.js"></script>

    <script>

        (function () {
            document.getElementById("fim").style.display = 'none';
        })();

        var camera, take, scene, renderer, geometry, material, piglet, tigger, honey, bee, pooh, sphere, light, plane,
            plane2, center, id;

        var mixers = [];
        var clock = new THREE.Clock();

        var back = new Audio('./sounds/background.ogg');
        back.loop = true;

        var win = new Audio('./sounds/win.ogg');

        var take = new Audio('./sounds/sparkle.ogg');

        // var mouseX = 0,
        //     mouseY = 0,
        //     mouseZ = 0;

        var maze = { width: 15, large: 15, cellSize: 500 };

        var angleY = 0;
        var angleX = 0;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 1.5;
        var incrementoX = Math.PI / (windowHalfX);
        var incrementoY = Math.PI / (windowHalfY);

        var posInitial = { x: 1, z: 14 };
        var ray;

        var camcontrol = 0;

        window.wallGeometries = [];

        document.onkeydown = checaInicio;

        // detecta espaço, remove a div de inicio e começa o jogo
        function checaInicio(e) {
            if (e.keyCode == '32') {
                document.getElementById("inicio").remove();
                back.play();
                init();
            }
        }

        function init() {

            scene = new THREE.Scene();

            camera1 = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            camera1.position.x = (posInitial.x - maze.width / 2) * maze.cellSize;
            camera1.position.z = (posInitial.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2;

            camera2 = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 10000);
            camera2.position.x = (posInitial.x - maze.width / 2) * maze.cellSize + 200;
            camera2.position.z = (posInitial.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 200;
            camera2.position.y += 100;

            var camera = camera1;

            center = new THREE.Vector3(camera.position.x + 250, 0, 0);

            geometrySphere = new THREE.SphereGeometry(50, 16, 16);
            material = new THREE.MeshPhongMaterial({ color: 0x00FF00, wireframe: true, side: THREE.DoubleSide });
            geometryPlane = new THREE.PlaneGeometry(maze.width * maze.cellSize, maze.large * maze.cellSize);
            geometryPlaneBasic = new THREE.PlaneGeometry(maze.cellSize, maze.cellSize, 1, 1);

            // carrega textura do céu
            var texture = new THREE.TextureLoader().load('textures/blue.png', function () {
                renderer.render(scene, camera);
                animate();
            });
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(maze.width, maze.large);
            texture.needsUpdate = true;
            material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });

            // carrega textura do chão
            var texture2 = new THREE.TextureLoader().load('textures/grass.png', {}, function () {
                renderer.render(scene, camera);
                animate();
            });
            texture2.wrapS = THREE.RepeatWrapping;
            texture2.wrapT = THREE.RepeatWrapping;
            texture2.repeat.set(maze.width, maze.large);
            texture2.needsUpdate = true;
            material2 = new THREE.MeshPhongMaterial({ map: texture2, side: THREE.DoubleSide });

            // carrega textura das paredes
            var wallTexture = new THREE.TextureLoader().load('textures/pedra.jpg');
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.needsUpdate = true;

            var mtlPooh = new THREE.MTLLoader();

            // pooh
            mtlPooh.setPath("./objects/pooh/");
            mtlPooh.load('Pooh.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("./objects/pooh/");
                objLoader.load('Pooh.obj', function (object) {
                    pooh = object;
                    pooh.position.x = (posInitial.x - maze.width / 2) * maze.cellSize;
                    pooh.position.y = -250;
                    pooh.position.z = (posInitial.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2;
                    pooh.rotation.y = 0;
                    pooh.scale.set(3.5, 3.5, 3.5);
                    pooh.visible = true;
                    scene.add(pooh);
                });

            });

            var mtlPiglet = new THREE.MTLLoader();

            // leitão
            var posLeitao = { x: 8, z: 4 };
            mtlPiglet.setPath("./objects/piglet/");
            mtlPiglet.load('Piglet.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("./objects/piglet/");
                objLoader.load('Piglet.obj', function (object) {
                    piglet = object;
                    piglet.position.z = (posLeitao.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 50;
                    piglet.position.y = -210;
                    piglet.position.x = (posLeitao.x - maze.width / 2) * maze.cellSize - 250;
                    piglet.scale.set(6, 6, 6);
                    scene.add(piglet);
                });

            });

            var mtlTigger = new THREE.MTLLoader();

            // tigrão
            var posTigrao = { x: 12, z: 2 };
            mtlTigger.setPath("./objects/tigger/");
            mtlTigger.load('Tigger.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("./objects/tigger/");
                objLoader.load('Tigger.obj', function (object) {
                    tigger = object;
                    tigger.position.z = (posTigrao.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 50;
                    tigger.position.y = -210;
                    tigger.position.x = (posTigrao.x - maze.width / 2) * maze.cellSize - 250;
                    tigger.scale.set(3, 3, 3);
                    scene.add(tigger);
                });

            });

            var mtlHoney = new THREE.MTLLoader();

            // pote de mel
            var posMel = { x: 12, z: 14 };
            var texture = new THREE.TextureLoader().load('./objects/honey.jpg');
            //var textureHoney = new THREE.MeshBasicMaterial({ map: texture });

            var objLoader = new THREE.OBJLoader();
            objLoader.setPath("./objects/");
            objLoader.load('honeyjar2.obj', function (object) {
                honey = object;
                honey.position.z = (posMel.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 50;
                honey.position.y = -200;
                honey.position.x = (posMel.x - maze.width / 2) * maze.cellSize - 250;
                honey.scale.set(20, 20, 20);
                honey.traverse(function (node) {
                    if (node.isMesh)
                        node.material.map = texture;
                });
                scene.add(honey);
            });


            var mtlBee = new THREE.MTLLoader();

            // abelha
            var posAbelha = { x: 2, z: 15 };

            var loader = new THREE.FBXLoader();
            loader.load('./objects/chicken/gallina.fbx', function (object) {
                chicken = object;
                chicken.position.z = (posAbelha.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 50;
                chicken.position.zo = chicken.position.z; // o stands for original
                chicken.position.y = -250;
                chicken.position.x = (posAbelha.x - maze.width / 2) * maze.cellSize - 250;
                chicken.position.xo = chicken.position.x; // o stands for original
                chicken.rotation.y = Math.PI;

                chicken.mixer = new THREE.AnimationMixer(chicken);
                mixers.push(chicken.mixer);
                if (mixers.length > 0) {
                    for (var i = 0; i < chicken.animations.length; i++) {
                        chicken.mixer.clipAction(chicken.animations[i]).play();
                    }
                }
                chicken.traverse(function (child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scene.add(chicken);
            });

            // objeto simples para a bola
            var posBola = { x: 1, z: 5 };
            sphere = new THREE.Mesh(geometrySphere, new THREE.MeshPhongMaterial({ map: new THREE.TextureLoader().load('textures/ball_texture.png') }));
            sphere.position.z = (posBola.z - maze.large / 2) * maze.cellSize - maze.cellSize / 2 + 50;
            sphere.position.x = (posBola.x - maze.width / 2) * maze.cellSize - 250;

            // objeto para o plano superior
            plane = new THREE.Mesh(geometryPlane, material);
            plane.side = THREE.DoubleSide;

            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 250;
            plane.position.x = 0;
            plane.position.z = 0;

            // objeto para o plano inferior
            plane2 = new THREE.Mesh(geometryPlane, material2);
            plane2.rotation.x = -Math.PI / 2;
            plane2.position.y = -250;
            plane2.position.x = 0;
            plane2.position.z = 0;

            var wall;
            var wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture, side: THREE.DoubleSide });


            // estrutura

            //           _________parede1_________
            //           |                        |
            //           |                        |
            //           |                        |
            // parede4   |                        | parede2
            //           |                        |
            //           |            x           |
            //           |_________parede3________|

            // x é onde começa

            // povoa paredes 2 e 4
            for (var i = 0; i < maze.width; i++) {
                // parede 2
                wall = new THREE.Mesh(geometryPlaneBasic, wallMaterial);
                wall.position.z = maze.large / 2 * maze.cellSize;
                wall.position.y = 0;
                wall.position.x = (i - maze.width / 2) * maze.cellSize + maze.cellSize / 2;
                scene.add(wall);
                wallGeometries.push(wall);
                // parede 4
                wall = new THREE.Mesh(geometryPlaneBasic, wallMaterial);
                wall.position.z = -maze.large / 2 * maze.cellSize;
                wall.position.y = 0;
                wall.position.x = (i - maze.width / 2) * maze.cellSize + maze.cellSize / 2;
                scene.add(wall);
                wallGeometries.push(wall);
            }

            // povoa paredes 1 e 3
            for (var i = 0; i < maze.large; i++) {
                // parede 1
                wall = new THREE.Mesh(geometryPlaneBasic, wallMaterial);
                wall.position.x = maze.width / 2 * maze.cellSize;
                wall.rotation.y = Math.PI / 2;
                wall.position.y = 0;
                wall.position.z = (i - maze.large / 2) * maze.cellSize + maze.cellSize / 2;
                scene.add(wall);
                wallGeometries.push(wall);
                // parede 3
                wall = new THREE.Mesh(geometryPlaneBasic, wallMaterial);
                wall.position.x = -maze.width / 2 * maze.cellSize;
                wall.rotation.y = Math.PI / 2;
                wall.position.y = 0;
                wall.position.z = (i - maze.large / 2) * maze.cellSize + maze.cellSize / 2;
                scene.add(wall);
                wallGeometries.push(wall);
            }

            var offsizeX = 0;
            var offsizeZ = 0;

            // povoa paredes intermediarias
            for (var i = 0; i < walls.length; i++) {
                wallData = walls[i];
                wall = new THREE.Mesh(geometryPlaneBasic, wallMaterial);
                if (wallData.orientation == 'front') {
                    offsizeX = -250;
                    offsizeZ = -maze.cellSize;
                } else if (wallData.orientation == 'back') {
                    offsizeX = -250;
                    offsizeZ = 0;
                } else if (wallData.orientation == 'left') {
                    offsizeX = -maze.cellSize;
                    offsizeZ = -250;
                } else if (wallData.orientation == 'right') {
                    offsizeX = 0;
                    offsizeZ = -250;
                }
                wall.position.x = (wallData.x - maze.width / 2) * maze.cellSize + offsizeX;
                wall.rotation.y = wallData.orientation == 'left' || wallData.orientation == 'right' ? Math.PI / 2 : 0;
                wall.position.y = 0;
                wall.position.z = (wallData.z - maze.large / 2) * maze.cellSize + offsizeZ;
                scene.add(wall);
                wallGeometries.push(wall);
            }


            scene.add(sphere);
            scene.add(plane);
            scene.add(plane2);

            //addiding some light to the scene
            light = new THREE.AmbientLight(0xffffff);
            light.position.set(0, 0, 1).normalize();
            scene.add(light);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight * .75);
            window.camera = camera;
            document.body.appendChild(renderer.domElement);


        };

        var bola = 0, leitao = 0, tigrao = 0, pote = 0;
        var Key = {
            _pressed: {},

            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            W: 87,
            S: 83,
            A: 65,
            D: 68,
            F: 70,
            SHIFT: 16,

            isDown: function (keyCode) {
                return this._pressed[keyCode];
            },

            onKeydown: function (event) {
                this._pressed[event.keyCode] = true;
            },

            onKeyup: function (event) {
                delete this._pressed[event.keyCode];
            }
        };

        window.addEventListener('keyup', function (event) { Key.onKeyup(event); }, false);
        window.addEventListener('keydown', function (event) { Key.onKeydown(event); }, false);

        function walk() {
            /*  ATENÇÃO, ESSAS LINHAS ESTAVAM COMENTADAS, NÃO SEI SE SÃO IMPORTANTE
             //        camera2.position.x = camera1.position.x + 100;
             //        camera2.position.z = camera1.position.z + 100;
            */

            if (Key.isDown(Key.UP) || Key.isDown(Key.W)) {
                if (Key.isDown(Key.SHIFT))
                    camera1.translateZ(-30);
                else
                    camera1.translateZ(-10);
            }

            if (Key.isDown(Key.RIGHT) || Key.isDown(Key.D)) {
                angleX += incrementoX * 45;
            }
            if (Key.isDown(Key.DOWN) || Key.isDown(Key.S)) {
                if (Key.isDown(Key.SHIFT))
                    camera1.translateZ(30);
                else
                    camera1.translateZ(10);
            }
            if (Key.isDown(Key.LEFT) || Key.isDown(Key.A)) {
                angleX -= incrementoX * 45;
            }
            if (Key.isDown(Key.F)) {
                Key._pressed[70] = false;
                if (camcontrol == 0) {
                    camera = camera2;
                    pooh.visible = true;
                    camcontrol = 1;
                }
                else {
                    camera = camera1;
                    pooh.visible = false;
                    camcontrol = 0;
                }
            }


        }


        function animate() {

            walk();
            //pontos de controle bezier

            center.x = windowHalfX * 100 * Math.cos(angleX);
            center.z = windowHalfX * 100 * Math.sin(angleX);

            id = requestAnimationFrame(animate);

            piglet.rotation.y += 0.01;
            sphere.rotation.x -= 0.01;
            tigger.rotation.y += 0.01;
            honey.rotation.y += 0.02;

            pooh.position.copy(camera1.position);
            pooh.position.y = -250;
            pooh.lookAt(center);
            pooh.updateMatrix();

            if (mixers.length > 0) {
                for (var i = 0; i < mixers.length; i++) {
                    mixers[i].update(clock.getDelta());
                }
            }

            var chickenX = (2 - maze.width / 2) * maze.cellSize;
            var chickenY = (14 - maze.large / 2) * maze.cellSize - maze.cellSize / 2;
            //rotacionar esse negocio

            //Bezier da abelha

            //PS se a abelha estiver se movendo muito rápida, mudar a divisão de 10 para 20,30 e etc.
            t = Math.abs(Math.sin((Math.floor(Date.now() / 10) % 360 * Math.PI / 180.0)))
            var x0 = 2.7, y0 = 5.46, x1 = 7.56, y1 = 18.9, x2 = 13.3, y2 = -3.15, x3 = 23.33, y3 = 9.45;

            chicken.position.x = chicken.position.xo + 2 * ((1 - t) * ((1 - t) * ((1 - t) * x0 + t * x1) + t * ((1 - t) * x1 + t * x2)) + t * ((1 - t) * ((1 - t) * x1 + t * x2) + t * ((1 - t) * x2 + t * x3)));
            chicken.position.z = chicken.position.zo + 4 * ((1 - t) * ((1 - t) * ((1 - t) * y0 + t * y1) + t * ((1 - t) * y1 + t * y2)) + t * ((1 - t) * ((1 - t) * y1 + t * y2) + t * ((1 - t) * y2 + t * y3)));


            var relativeCameraOffset = new THREE.Vector3(0, 100, -75);
            var cameraOffset = relativeCameraOffset.applyMatrix4(pooh.matrixWorld);

            camera2.position.x = cameraOffset.x;
            camera2.position.z = cameraOffset.z;

            var control = 0;
            ray2 = new THREE.Raycaster(camera2.position, center.clone().normalize());
            ray2.far = 300;
            // se houver colisão com as paredes
            if (ray2.intersectObjects(wallGeometries).length > 0) {
                camera = camera1;
                pooh.visible = false;
            }
            else if (camcontrol == 1 && camera == camera1) {
                camera = camera2;
                pooh.visible = true;
            }

            var ray = new THREE.Raycaster(camera1.position, center.clone().normalize());
            ray.far = 150;
            if (ray.intersectObjects(wallGeometries).length > 0) { // Se encostou numa parede, rebobine
                if (Key.isDown(Key.UP) || Key.isDown(Key.W)) {
                    if (Key.isDown(Key.SHIFT)) {
                        camera1.translateZ(30);
                    }
                    else {
                        camera1.translateZ(10);

                    }
                }
                if (Key.isDown(Key.RIGHT) || Key.isDown(Key.D)) {
                    camera1.translateX(-30);
                }
                if (Key.isDown(Key.DOWN) || Key.isDown(Key.S)) {
                    if (Key.isDown(Key.SHIFT)) {
                        camera1.translateZ(-30);
                    }
                    else {
                        camera1.translateZ(-10);
                    }
                }
                if (Key.isDown(Key.LEFT) || Key.isDown(Key.A)) {
                    camera1.translateX(30);
                }

            }
            else {
                if (Key.isDown(Key.UP) || Key.isDown(Key.W) || Key.isDown(Key.DOWN) || Key.isDown(Key.S)) // se não balance a cabeça
                {
                    angleY += incrementoY;
                    if (Key.isDown(Key.SHIFT)) {
                    center.y = 800 * Math.sin(angleY * 80);
                    }
                    else{
                        center.y = 400 * Math.sin(angleY * 80);
                    }
                }
            }

            camera1.lookAt(center);
            camera2.lookAt(center);
            renderer.render(scene, camera);
        };

    </script>
</body>

</html>